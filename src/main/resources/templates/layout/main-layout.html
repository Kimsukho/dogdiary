<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
<head>
    <head th:replace="fragments/head :: headFragment"></head>
    <link rel="stylesheet" th:href="@{/css/main.css}">
</head>
<body>
    <div class="wrapper">
        <aside th:replace="fragments/sidebar :: sidebar"></aside>

        <div class="main-content-wrapper" id="mainContentWrapper">
            <header th:replace="fragments/header :: header(title=${title})"></header>
            
            <main layout:fragment="content"></main>

            <th:block layout:fragment="script"></th:block>
            
            <footer th:replace="fragments/footer :: footer"></footer>
        </div>
    </div>

    <div id="toast">메시지가 여기에 표시됩니다!</div>

    <!-- 알림 모달 -->
    <div id="notificationModal" class="notification-modal">
        <div class="notification-modal-content">
            <div class="notification-modal-header">
                <h3><i class="fas fa-bell"></i> 알림</h3>
                <button class="notification-modal-close" id="closeNotificationModal">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="notification-modal-body">
                <div class="notification-list" id="notificationList">
                    <!-- 알림 목록이 여기에 동적으로 추가됩니다 -->
                    <div class="notification-empty">
                        <i class="fas fa-bell-slash"></i>
                        <p>새로운 알림이 없습니다.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 공통 API JavaScript 파일 -->
    <script th:src="@{/js/api-common.js}"></script>

    <script>
        // 알림 모달 전역 함수 정의 (header fragment보다 먼저 실행되도록)
        window.openNotificationModal = function() {
            const notificationModal = document.getElementById('notificationModal');
            if (notificationModal) {
                notificationModal.style.display = 'flex';
                // 모달이 열릴 때 알림 목록 새로고침
                loadNotifications();
            } else {
                console.warn('알림 모달을 찾을 수 없습니다.');
            }
        };

        window.closeNotificationModal = function() {
            const notificationModal = document.getElementById('notificationModal');
            if (notificationModal) {
                notificationModal.style.display = 'none';
            }
        };

        // 알림 모달 이벤트 리스너 초기화
        document.addEventListener('DOMContentLoaded', function() {
            const notificationModal = document.getElementById('notificationModal');
            const closeNotificationModal = document.getElementById('closeNotificationModal');

            if (!notificationModal) {
                console.warn('알림 모달을 찾을 수 없습니다.');
                return;
            }

            // 닫기 버튼 클릭 이벤트
            if (closeNotificationModal) {
                closeNotificationModal.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    window.closeNotificationModal();
                });
            }

            // 모달 외부 클릭 시 닫기
            notificationModal.addEventListener('click', function(e) {
                if (e.target === notificationModal) {
                    window.closeNotificationModal();
                }
            });

            // ESC 키로 모달 닫기
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && notificationModal && notificationModal.style.display === 'flex') {
                    window.closeNotificationModal();
                }
            });
        });

        // 페이지 로드 시 테마, 폰트 크기, 애니메이션 효과 적용
        (function() {
            // 관리자 모드인지 확인
            const isAdminMode = window.location.pathname.startsWith('/admin/');
            
            // 관리자 모드일 때는 항상 라이트 테마 강제 적용
            if (isAdminMode) {
                document.documentElement.setAttribute('data-theme', 'light');
            } else {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
            }
            
            const savedFontSize = localStorage.getItem('fontSize') || 'medium';
            document.documentElement.setAttribute('data-font-size', savedFontSize);
            
            const savedAnimations = localStorage.getItem('animations');
            const animationsEnabled = savedAnimations === null ? true : savedAnimations === 'true';
            document.documentElement.setAttribute('data-animations', animationsEnabled ? 'true' : 'false');
        })();

        document.addEventListener('DOMContentLoaded', () => {
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebar = document.getElementById('sidebar'); // sidebar fragment에 id="sidebar"가 추가되어야 함

            if (!sidebar) {
                console.error("Sidebar element with id 'sidebar' not found. Please ensure sidebar fragment has id='sidebar'.");
                return;
            }

            const sidebarTitle = sidebar.querySelector('.sidebar-title');
            const sidebarCollapsedTitle = sidebar.querySelector('.sidebar-collapsed-title');

            function setInitialSidebarState() {
                if (window.innerWidth <= 1024) { // 태블릿 사이즈까지는 기본 접힘
                    sidebar.classList.add('collapsed');
                    if (sidebarTitle) sidebarTitle.style.display = 'none';
                    if (sidebarCollapsedTitle) sidebarCollapsedTitle.style.display = 'block';
                } else {
                    sidebar.classList.remove('collapsed');
                    if (sidebarTitle) sidebarTitle.style.display = 'block';
                    if (sidebarCollapsedTitle) sidebarCollapsedTitle.style.display = 'none';
                }
            }
            setInitialSidebarState();

            if (sidebarToggle) { 
                sidebarToggle.addEventListener('click', () => {
                    sidebar.classList.toggle('collapsed');
                    
                    if (sidebar.classList.contains('collapsed')) {
                        if (sidebarTitle) sidebarTitle.style.display = 'none';
                        if (sidebarCollapsedTitle) sidebarCollapsedTitle.style.display = 'block';
                    } else {
                        if (sidebarTitle) sidebarTitle.style.display = 'block';
                        if (sidebarCollapsedTitle) sidebarCollapsedTitle.style.display = 'none';
                    }
                });
            } else {
                console.warn("Sidebar toggle button with id 'sidebarToggle' not found. Sidebar toggling will not work.");
            }

            function handleResize() {
                if (window.innerWidth <= 1024) {
                    if (!sidebar.classList.contains('collapsed')) { // 아직 접히지 않았다면
                        sidebar.classList.add('collapsed');
                        if (sidebarTitle) sidebarTitle.style.display = 'none';
                        if (sidebarCollapsedTitle) sidebarCollapsedTitle.style.display = 'block';
                    }
                } else { 
                    // PC 화면에서는 기본적으로 펼쳐진 상태 (혹은 이전 상태 유지)
                    sidebar.classList.remove('collapsed');
                    if (sidebarTitle) sidebarTitle.style.display = 'block';
                    if (sidebarCollapsedTitle) sidebarCollapsedTitle.style.display = 'none';
                }
            }
            window.addEventListener('resize', handleResize);
        });

        function showToast(message) {
            const toast = document.getElementById('toast');
            if (toast) {
                toast.textContent = message;
                toast.classList.add('reveal');
                setTimeout(() => {
                    toast.classList.remove('reveal');
                }, 3000);
            } else {
                console.warn("Toast element with id 'toast' not found.");
            }
        }

        // 알림 Polling 기능
        let notificationPollingInterval = null;
        let lastNotificationCheck = null;

        // 알림 목록 로드
        async function loadNotifications() {
            try {
                const response = await axios.get('/api/notifications?limit=50');
                if (response.data.returnCode === 'SUCCESS') {
                    const notifications = response.data.resultData || [];
                    renderNotifications(notifications);
                    updateUnreadBadge();
                }
            } catch (error) {
                console.error('알림 조회 오류:', error);
            }
        }

        // 읽지 않은 알림 개수 업데이트
        async function updateUnreadBadge() {
            try {
                const response = await axios.get('/api/notifications/unread-count');
                if (response.data.returnCode === 'SUCCESS') {
                    const unreadCount = response.data.resultData || 0;
                    const notificationBtn = document.getElementById('notificationBtn');
                    if (notificationBtn) {
                        // 기존 배지 제거
                        const existingBadge = notificationBtn.querySelector('.notification-badge');
                        if (existingBadge) {
                            existingBadge.remove();
                        }
                        
                        // 읽지 않은 알림이 있으면 배지 표시
                        if (unreadCount > 0) {
                            const badge = document.createElement('span');
                            badge.className = 'notification-badge';
                            badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
                            notificationBtn.appendChild(badge);
                        }
                    }
                }
            } catch (error) {
                console.error('읽지 않은 알림 개수 조회 오류:', error);
            }
        }

        // 알림 목록 렌더링
        function renderNotifications(notifications) {
            const notificationList = document.getElementById('notificationList');
            if (!notificationList) return;

            if (notifications.length === 0) {
                notificationList.innerHTML = `
                    <div class="notification-empty">
                        <i class="fas fa-bell-slash"></i>
                        <p>새로운 알림이 없습니다.</p>
                    </div>
                `;
                return;
            }

            notificationList.innerHTML = '';
            notifications.forEach(notification => {
                const notificationItem = document.createElement('div');
                notificationItem.className = `notification-item ${notification.is_read == 0 ? 'unread' : ''}`;
                
                // 알림 타입별 아이콘 설정
                let iconClass = 'info';
                if (notification.type === 'SCHEDULE') {
                    iconClass = 'warning';
                } else if (notification.type === 'DIARY') {
                    iconClass = 'info';
                } else if (notification.type === 'SYSTEM') {
                    iconClass = 'error';
                }

                // 날짜 포맷팅
                const date = new Date(notification.created_at);
                const timeAgo = formatTimeAgo(date);

                notificationItem.innerHTML = `
                    <div class="notification-icon ${iconClass}">
                        <i class="fas ${notification.type === 'SCHEDULE' ? 'fa-calendar' : notification.type === 'DIARY' ? 'fa-book-open' : 'fa-info-circle'}"></i>
                    </div>
                    <div class="notification-content">
                        <div class="notification-title">${escapeHtml(notification.title || '')}</div>
                        <div class="notification-message">${escapeHtml(notification.message || '')}</div>
                        <div class="notification-time">${timeAgo}</div>
                    </div>
                    <div class="notification-actions">
                        ${notification.is_read == 0 ? 
                            `<button class="notification-mark-read" data-id="${notification.id}" title="읽음 처리">
                                <i class="fas fa-check"></i>
                            </button>` : ''}
                        <button class="notification-delete" data-id="${notification.id}" title="삭제">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;

                // 읽음 처리 버튼
                const markReadBtn = notificationItem.querySelector('.notification-mark-read');
                if (markReadBtn) {
                    markReadBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await markNotificationAsRead(notification.id);
                    });
                }

                // 삭제 버튼
                const deleteBtn = notificationItem.querySelector('.notification-delete');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await deleteNotification(notification.id);
                    });
                }

                // 알림 클릭 시 읽음 처리
                notificationItem.addEventListener('click', async () => {
                    if (notification.is_read == 0) {
                        await markNotificationAsRead(notification.id);
                    }
                });

                notificationList.appendChild(notificationItem);
            });
        }

        // 시간 포맷팅 (예: "5분 전", "1시간 전", "2024-01-01")
        function formatTimeAgo(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);

            if (minutes < 1) return '방금 전';
            if (minutes < 60) return `${minutes}분 전`;
            if (hours < 24) return `${hours}시간 전`;
            if (days < 7) return `${days}일 전`;
            
            return date.toLocaleDateString('ko-KR', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
        }

        // HTML 이스케이프
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 알림 읽음 처리
        async function markNotificationAsRead(notificationId) {
            try {
                const response = await axios.post('/api/notifications/mark-read', { id: notificationId });
                if (response.data.returnCode === 'SUCCESS') {
                    await loadNotifications();
                    await updateUnreadBadge();
                }
            } catch (error) {
                console.error('알림 읽음 처리 오류:', error);
            }
        }

        // 알림 삭제
        async function deleteNotification(notificationId) {
            try {
                const response = await axios.post('/api/notifications/delete', { id: notificationId });
                if (response.data.returnCode === 'SUCCESS') {
                    await loadNotifications();
                    await updateUnreadBadge();
                }
            } catch (error) {
                console.error('알림 삭제 오류:', error);
            }
        }

        // 알림 Polling 시작
        function startNotificationPolling() {
            // 관리자가 아닌 경우에만 polling 시작
            const notificationBtn = document.getElementById('notificationBtn');
            if (!notificationBtn) return; // 관리자는 알림 버튼이 없음

            // 초기 로드
            loadNotifications();
            updateUnreadBadge();

            // 30초마다 알림 조회
            notificationPollingInterval = setInterval(() => {
                loadNotifications();
                updateUnreadBadge();
            }, 30000); // 30초
        }

        // 알림 Polling 중지
        function stopNotificationPolling() {
            if (notificationPollingInterval) {
                clearInterval(notificationPollingInterval);
                notificationPollingInterval = null;
            }
        }

        // 페이지 로드 시 알림 Polling 시작
        document.addEventListener('DOMContentLoaded', () => {
            startNotificationPolling();
        });

        // 페이지 언로드 시 Polling 중지
        window.addEventListener('beforeunload', () => {
            stopNotificationPolling();
        });
    </script>
</body>
</html>